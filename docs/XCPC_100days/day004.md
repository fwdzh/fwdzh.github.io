# 第四天 2025-07-25

今天还行吧，等会再VP一把div2。

## [CF2125D](https://codeforces.com/contest/2125/problem/D)

前几天的比赛，当时咋想不明白的。其实也没有很难。

我比赛时以为如果要选 $[l, r]$，那么所有与这个段相交的段都不能选，要直接乘不选的概率。

但是这个东西我不会算，而且现在再想想呢，一个段可能会和多个段都重合，所以不能这样乘的。可以只考虑左端点或右端点在这个区间里的线段。这样就不会乘少了或乘多了。

```cpp
constexpr int mod = 998244353;
ll ksm(ll a, ll b) {
    ll res = 1;
    while (b) {
        if (b & 1)
            res = res * a % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return res;
}
void ChatGptDeepSeek() // Date: 2025-07-25
{                      // Time: 18:03:59 
    int n, m;
    cin >> n >> m;
    // vector<array<int, 4>> vec(n);
    vector<vector<pii>> vec(m + 1);
    for(int i = 0; i < n; i++){
        int l, r, p, q;
        cin >> l >> r >> p >> q;
        vec[r].push_back({l, p * ksm(q, mod - 2) % mod});
    }
    vector<long long> pre(m + 1), dp(m + 1);
    pre[0] = 1, dp[0] = 1;
    for(int i = 1; i <= m; i++){
        pre[i] = pre[i - 1];
        for(auto [l, p] : vec[i]){
            pre[i] = pre[i] * (1 - p) % mod;
        }
        pre[i] = (pre[i] + mod) % mod;
    }
    auto get = [&](int l, int r){
        return pre[r] * ksm(pre[l - 1], mod - 2) % mod;
    };
    for(int i = 1; i <= m; i++){
        for(auto [l, p] : vec[i]){
            dp[i] = dp[i] + dp[l - 1] * p % mod * get(l, i) % mod * ksm(1 - p, mod - 2) % mod;
            dp[i] = dp[i] % mod;
        }
    }
    dp[m] = (dp[m] + mod) % mod;
    cout << dp[m] << '\n';
}
```

## [ABC414E](https://atcoder.jp/contests/abc414/tasks/abc414_e)

这种题其实也挺多的，前两周的题，但是不会写。其实也并没有那么难。

$a \mod b \ne a$，因此 $a > b > c$
$c > 0$，所以 $a \nmid b$

于是我们只需要统计 $a > b$ 且 $a \nmid b$ 的对的数量。

这个看起来就很不好想，我们可以反过来想，用总的对的数量减去整除的对的数量。

当 $a = b$ 时，$a \mid b$，因此可以看成 $a \ge b$ 且 $a \nmid b$，这样会方便一些。

那么答案就是 $\frac{n(n+1)}{2}-\sum_{b = 1}^n\frac{n}{b}$，但我们不能直接算，因为复杂度很高。

但是如果考虑值，$\frac{b}{i}$ 最多只会有 $2\sqrt{n}$ 个值。

当 $b \le \sqrt{n}$ 时，最多会产生 $\sqrt{n}$ 个值；当 $b > sqrt{n}$ 时，$\frac{n}{b} \le \sqrt{n}$，因此最多也只会有 $\sqrt{n}$ 个值。

那么我们初始时让 $L = 1$， 我们找到最大的 $R$ 使得 $\lfloor \frac{N}{R} \rfloor = \lfloor \frac{N}{L} \rfloor$，分块处理。

$\lfloor \frac{N}{R} \rfloor \ge \lfloor \frac{N}{L} \rfloor$， 因此 $R \le \lfloor \frac{N}{\lfloor \frac{N}{L} \rfloor} \rfloor$。

所以对于 $L$，最大的满足条件的 $R$ 就是 $\lfloor \frac{N}{\lfloor \frac{N}{L} \rfloor} \rfloor$。对于 $i \in [L, R]$, $\lfloor \frac{N}{i} \rfloor = \lfloor \frac{N}{L} \rfloor$。

```cpp
/*
a % b != a a > b
a % b < b
a > b > c
a > b && a % b != 0
n * (n - 1) / 2 - 整除的对的数量

n / 1 + n / 2 + n / 3 ... 
值的数量是有限的 sqrt(n) 范围

n / l <= n / r
r <= n / (n / l)
*/
#include<bits/stdc++.h>
using namespace std;

constexpr int mod = 998244353;
long long ksm(long long a, long long b)
{
    long long res = 1;
    while(b){
        if(b & 1) res = res * a % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return res;
}
long long inv(long long x) {return ksm(x, mod - 2);}
int main()
{
    ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
    long long N;
    cin >> N;
    long long ans = N % mod;
    ans = ans * (ans + 1) % mod * inv(2) % mod;
    for(long long L = 1, R; L <= N; L = R + 1){
        R = N / (N / L);
        int len = (R - L + 1) % mod;
        int val = (N / L) % mod;
        ans -= 1LL * len * val % mod;
        ans %= mod;
    }
    cout << (ans + mod) % mod << '\n';
    return 0;
}
```