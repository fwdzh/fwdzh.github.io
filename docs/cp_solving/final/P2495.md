# [P2495 [SDOI2011] 消耗战](https://www.luogu.com.cn/problem/P2495)

tag : 虚树， dp

## 题意

有一颗以 $1$ 为顶点的树，给出 $q$ 次询问，对于每次询问，给出 $k$ 个点，删除一些边，使得这些边权值和最小且这些点均无法到达 节点$1$。($\sum k \le 5 \times 10 ^ 5$)

## solution

若无询问次数限制，可以遍历整颗树dp，$dp_{u}$ 表示以 $u$ 为根节点的子树无特殊节点的最小花费。那么对于 $u$ 的每个子结点 $v$, 如果 $v$ 是特殊点，则$dp_u += w$； 否则 $dp_u += min(dp_v, w)$。但是 $q$ 次询问，如果每次都遍历整棵树就非常慢了。

我们可以只用虚树，虚树就是只将关键点以及它们两两之间的 lca 建一颗新的树，这样单次询问只需要 $O(k)$ 复杂度。

其实难点只在建虚树，不然只有这个 dp，估计只是个绿题了。

## code

其实也不难，也是虚树的木板题吧，但是当时写的代码有一点点乱，刚学写的。。。以后如果有空，来重写一下这题的代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
using LL = long long;

constexpr int N = 250000 + 1;
constexpr int inf = int(1e9);
vector<pair<int, int>> g[N], vg[N];
LL dp[N];
int tot, fa[N][21], we[N][21], dep[N], dfn[N];
bool have[N];
void dfs1(int u, int p)
{
    dfn[u] = ++tot;
    dep[u] = dep[p] + 1;
    for(int i = 1; i <= 20; i++){
        fa[u][i] = fa[fa[u][i - 1]][i - 1];
        we[u][i] = min(we[u][i - 1], we[fa[u][i - 1]][i - 1]);
    }
    for(auto [v, w] : g[u]){
        if(v == p) continue;
        fa[v][0] = u;
        we[v][0] = w;
        dfs1(v, u);
    }
}
int lca(int x, int y)
{
    if(dep[x] < dep[y]) swap(x, y);
    for(int i = 0, z = dep[x] - dep[y]; z; i++, z >>= 1){
        if(z & 1)
            x = fa[x][i];
    }
    if(x == y) return x;
    for(int i = 20; i >= 0; i--){
        if(fa[x][i] != fa[y][i]){
            x = fa[x][i], y = fa[y][i];
        }
    }
    return fa[x][0];
}
int get(int x, int y)
{
    if(dep[x] < dep[y]) swap(x, y);
    int res = inf;
    for(int i = 0, z = dep[x] - dep[y]; z; i++, z >>= 1){
        if(z & 1)
            res = min(res, we[x][i]), x = fa[x][i];
    }
    return res;
}
void build(vector<int> p)
{
    int k = p.size();
    for(auto x : p)
        have[x] = true;
    ranges::sort(p, [&](int x, int y){return dfn[x] < dfn[y];});
    for(int i = 0; i + 1 < k; i++){
        p.push_back(lca(p[i], p[i + 1]));
    }
    ranges::sort(p, [&](int x, int y){return dfn[x] < dfn[y];});
    p.erase(unique(p.begin(), p.end()), p.end());
    for(int i = 0; i + 1 < p.size(); i++){
        int L = lca(p[i], p[i + 1]);
        int w = get(L, p[i + 1]);
        vg[L].push_back({p[i + 1], w});
    }
    if(p[0] != 1) vg[1].push_back({p[0], get(1, p[0])});
}
void dfs2(int u)
{
    if(have[u]){
        dp[u] = inf;
    }else{
        for(auto [v, w] : vg[u]){
            dfs2(v);
            dp[u] += min(dp[v], w + 0ll);
        }
    }
    for(auto [v, _] : vg[u])
        dp[v] = 0, vg[v].clear();
}
int main()
{
    ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
    int n;
    cin >> n;
    for(int i = 1; i < n; i++){
        int u, v, w;
        cin >> u >> v >> w;
        g[u].push_back({v, w});
        g[v].push_back({u, w});
    }
    dfs1(1, 0);
    int m;
    cin >> m;
    while(m--){
        int k; cin >> k;
        vector<int> p(k);
        for(int i = 0; i < k; i++)
            cin >> p[i];
        build(p);
        dfs2(1);
        cout << dp[1] << '\n';
        for(auto x : p) have[x] = false;
        vg[1].clear();
        dp[1] = 0;
    }
    return 0;
}
```