# [P2272 [ZJOI2007] 最大半连通子图](https://www.luogu.com.cn/problem/P2272)

## 题意

最大半联通子图是指，节点数量最多，且对于其中任意两个点 $u, v$，要么 $u$ 可以到达 $v$，要么 $v$ 可以到达 $u$的子图。

## solution

强连通分量里的点肯定都满足，缩点成 DAG 之后，最大半联通子图肯定是一条链。

直接 dp 就可以了。

## code

直接建新图然后去除重边就行了。

```cpp
#include<bits/stdc++.h>
using namespace std;

struct graph{
    int n, m;
    vector<int> head, nxt, from, to;
    vector<int> dfn, low, in_stack, scc, sz, stk;
    int totEdge, tot, sc;
    graph(int __n, int __m){
        n = __n, m = __m;
        head.assign(n + 5, 0);
        nxt.assign(m + 5, 0);
        from.assign(m + 5, 0);
        to.assign(m + 5, 0);
        totEdge = 1;

        dfn = low = in_stack = scc = sz = vector<int> (n + 5, 0);
        tot = sc = 1;
    }
    void addEdge(int u, int v){
        nxt[totEdge] = head[u];
        head[u] = totEdge;
        from[totEdge] = u;
        to[totEdge] = v;
        ++totEdge;
    }
    void tarjan(int u){
        dfn[u] = low[u] = ++tot;
        in_stack[u] = true, stk.push_back(u);
        for(int i = head[u]; i; i = nxt[i]){
            int v = to[i];
            if(!dfn[v]){
                tarjan(v);
                low[u] = min(low[u], low[v]);
            }else if(in_stack[v])
                low[u] = min(low[u], dfn[v]);
        }
        if(low[u] == dfn[u]){
            ++sc;
            for(int k; k != u; ){
                k = stk.back(); stk.pop_back();
                scc[k] = sc, sz[sc]++;
                in_stack[k] = false;
            }
        }
    }
};
int ans[100010], f[100010], used[100010];
int main()
{
    ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
    int n, m, mod; cin >> n >> m >> mod;
    graph g(n, m * 2);
    for(int i = 1; i <= m; i++){
        int u, v; cin >> u >> v;
        g.addEdge(u, v);
    }
    for(int i = 1; i <= n; i++){
        if(!g.dfn[i]) g.tarjan(i);
    }
    graph ng(n, m * 2);
    for(int i = 1; i < g.totEdge; i++){
        int u = g.from[i], v = g.to[i];
        if(g.scc[u] != g.scc[v]){
            ng.addEdge(g.scc[u], g.scc[v]);
        }
    }
    for(int i = 1; i <= g.sc; i++)
        ans[i] = g.sz[i], f[i] = 1;
    for(int i = g.sc; i >= 1; i--){
        // 更新相连的边
        for(int e = ng.head[i]; e; e = ng.nxt[e]){
            int v = ng.to[e];
            if(used[v] == i) continue;
            used[v] = i;
            if(ans[v] < ans[i] + g.sz[v]){
                ans[v] = ans[i] + g.sz[v];
                f[v] = f[i];
            }else if(ans[v] == ans[i] + g.sz[v]){
                f[v] = (f[v] + f[i]) % mod;
            }
        }
    }
    int C = 0, mx = 0;
    for(int i = 1; i <= g.sc; i++){
        if(ans[i] > mx){
            mx = ans[i];
            C = f[i];
        }else if(ans[i] == mx){
            C = (C + f[i]) % mod;
        }
    }
    cout << mx << '\n' << C << '\n';
    return 0;
}
```