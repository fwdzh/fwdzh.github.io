# [P1972 [SDOI2009] HH的项链](https://www.luogu.com.cn/problem/P1972)

tag : 树状数组

## 题意

一个数组 $a$，有 $q$ 次询问，每次询问 $[l, r]$ 之前不同数字的个数。

## solution

看起来非常困难，实则只需要非常简单的树状数组就可以。。。虽然也能用莫队，但是得卡常，树状数组真智慧吧。

按 $r$ 排序，记录每个数字出现的最后一个位置，把这些位置的值设为 1,那么这个就变成单点修改加区间查询了，就非常简单。

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
using LL = long long;

constexpr int N = int(1e6) + 1;
struct node{
    int l, r, id;
}Q[N];
int a[N], lst[N], b[N], ans[N];
inline int lowbit(int x){return (x) & (-x);}
inline void add(int i, int x)
{
    while(i < N){
        b[i] += x;
        i += lowbit(i);
    }
}
inline int query(int i)
{
    int res = 0;
    while(i){
        res += b[i];
        i -= lowbit(i);
    }
    return res;
}

int main()
{
    ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
    int n; cin >> n;
    for(int i = 1; i <= n; i++){
        cin >> a[i];
    }
    int q; cin >> q;
    for(int i = 0; i < q; i++){
        cin >> Q[i].l >> Q[i].r;
        Q[i].id = i;
    }
    sort(Q, Q + q, [&](node x, node y){
        return x.r < y.r;
    });
    for(int i = 1, j = 0; i <= n; i++){
        if(lst[a[i]])
            add(lst[a[i]], - 1);
        lst[a[i]] = i;
        add(lst[a[i]], 1);
        while(j < q && Q[j].r == i){
            ans[Q[j].id] = query(i) - query(Q[j].l - 1);
            j++;
        }
    }
    for(int i = 0; i < q; i++)
        cout << ans[i] << "\n";
    return 0;
}
```

这是我写的莫队的，也贴一下吧。

奇数块升序偶数块降序可以省时间，然后遇到莫队的题，尽量别用 vector 了，因为这个算法本来就卡时间，vector 时间还多那么多。

```cpp
#include<bits/stdc++.h>
using namespace std;
using LL = long long;

constexpr int N = int(1e6) + 1;
struct node{
    int l, r, id;
}Q[N];
int a[N], b[N], pos[N], cnt[N], ans[N], res;
inline void add (int i){
    if(!cnt[a[i]]) res++;
    cnt[a[i]]++;
}
inline void del (int i){
    cnt[a[i]]--;
    if(!cnt[a[i]]) res--;
}
// bool cmp(node x, node y)
// {
//     return pos[x.l] == pos[y.l] ? x.r < y.r : pos[x.l] < pos[y.l];
//     // return pos[x.l] == pos[y.l] ? (pos[x.l] & 1 ? x.r < y.r : x.r > y.r) : pos[x.l] < pos[y.l];
// }
int main()
{
    ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
    int n; cin >> n;
    // vector<int> a(n + 1), pos(n + 1), cnt(N);
    int siz = sqrt(n);
    for(int i = 1, tot = 0; i <= n; i++){
        cin >> a[i];
        if(!b[a[i]]){
            b[a[i]] = ++tot;
        }
        a[i] = b[a[i]];
        pos[i] = i / siz;
    }
    int q; cin >> q;
    // vector<node> Q(q);
    for(int i = 0; i < q; i++){
        cin >> Q[i].l >> Q[i].r;
        Q[i].id = i;
    }
    sort(Q, Q + q, [&](node x, node y){
        return pos[x.l] == pos[y.l] ? (pos[x.l] & 1 ? x.r < y.r : x.r > y.r) : pos[x.l] < pos[y.l];
    });
    // sort(Q, Q + q, cmp);
    int L = 1, R = 0;
    // vector<int> ans(q);

    for(int i = 0; i < q; i++){
        while(Q[i].l < L)
            add(--L);
        while(Q[i].l > L)
            del(L++);
        while(Q[i].r < R)
            del(R--);
        while(Q[i].r > R)
            add(++R);
        // for(int j = 1; j <= 5; j++)
        //     cerr << cnt[j] << " \n" [j == 5];
        ans[Q[i].id] = res;
    }
    for(int i = 0; i < q; i++)
        cout << ans[i] << "\n";
    return 0;
}
```