>因为感觉多写一点对自己有一点点难度的题，会帮助很大。所以决定试一下。比如每天写3道cf rating在\*1600-\*1800的题目，看看一段时间之后能不能稳定蓝名水平不要掉到青。。。
>
>然后有时候可能也会写洛谷的绿色难度的题，大致也是最低cf *1600的题。说白了其实大部分都是看题解的，甚至可能看题没看一会就看题解。只能说我试一下吧，也许是骗自己，也许是有帮助，总比什么都不做好。

## day1 2月19日

### [CF2022C](https://codeforces.com/contest/2022/problem/C) *1800

这个 DP 太牛。。。

每次分割完区域之后，末尾只有几种状态:

```
XX   X.   XX
X.   XX   XX 
```

X表示已经被选出来，$ .$ 表示没有被选。

因为如果放了一个长度为3的，那么底下也一定得放一个。所以状态其实可以看成只有这3种。然后进行DP，看每一种状态的票数是多少。

我刚才还在想，它怎么保证答案一定是合法的划分呢？

其实因为可以倒着看的，最后是全部填满了，所以逆着推回去一定会是全部填满的。

```cpp
void solve()
{
    /*
    dp0 dp1 dp2
    X.  XX  XX
    XX  X.  XX 
    */
    int n;
    cin>>n;
    string s[2];
    cin>>s[0]>>s[1];
    s[0]=" "+s[0];
    s[1]=" "+s[1];
    auto check1=[&](int i){
        return ((s[0][i+1]=='A')+(s[1][i+1]=='A')+(s[1][i+2]=='A'))>=2;
    };
    auto check2=[&](int i){
        return (s[0][i+1]=='A')+(s[1][i+1]=='A')+(s[0][i+2]=='A')>=2;
    };
    auto check3=[&](int i){
        int res=0;
        assert(i+3<=n);
        if((s[0][i+1]=='A')+(s[0][i+2]=='A')+(s[0][i+3]=='A')>=2) res++;
        if((s[1][i+1]=='A')+(s[1][i+2]=='A')+(s[1][i+3]=='A')>=2) res++;
        return res;
    };
    vector<vi> dp(n+1,vi(3));
    for(int i=1;i<=n;i++){
        if(i+1<=n){
            cmax(dp[i+1][0],dp[i-1][2]+check1(i-1));
            cmax(dp[i+1][1],dp[i-1][2]+check2(i-1));
            cmax(dp[i+1][2],dp[i][0]+((s[0][i]=='A')+(s[0][i+1]=='A')+(s[1][i+1]=='A')>=2));
            cmax(dp[i+1][2],dp[i][1]+((s[1][i]=='A')+(s[0][i+1]=='A')+(s[1][i+1]=='A')>=2));
        }
        if(i+3<=n){
            cmax(dp[i+3][0],dp[i][0]+((s[0][i]=='A')+(s[0][i+1]=='A')+(s[0][i+2]=='A')>=2)+((s[1][i+1]=='A')+(s[1][i+2]=='A')+(s[1][i+3]=='A')>=2));
            cmax(dp[i+3][1],dp[i][1]+((s[1][i]=='A')+(s[1][i+1]=='A')+(s[1][i+2]=='A')>=2)+((s[0][i+1]=='A')+(s[0][i+2]=='A')+(s[0][i+3]=='A')>=2));
        }
        if(i+2<=n){
            cmax(dp[i+2][2],dp[i-1][2]+check3(i-1));
        }
    }
    // for(int i=1;i<=n;i++)
    //     cerr<<dp[i][0]<<" "<<dp[i][1]<<" "<<dp[i][2]<<" \n";
    cout<<dp[n][2]<<'\n';
}
```

### [CF1949I](https://codeforces.com/contest/1949/problem/I) *1800

这是之前咱们一起打的那一场，只写了一题。

那个圆盘的题。。。

看了题解感觉就好有道理，而且不是很难想。

~~说白了目前还是得多抄题解才能进步。。。~~

因为半径之和要严格减小，那些不与其他圆盘相切的，很显然可以直接减小就行。如果有若干个相切的挨在一起，如果有一个圆盘半径减小，那么和它相邻的一定要增加。我们只需要检查有没有合法的方案，且增大减小的数量不同，则可以使得总的半径减小。

可以把相切的连边建图，这样会有若干个连通块。检查有没有可以减小半径的。题解说好像这样黑白染色的就是二分图，有空看看这个概念。

啊。我服了，一个 continue 的位置放错了导致 WA 了半小时才发现，一直 RE ，幸好能看错在第几个测试点，RE 很多时候可能是因为内存暴了，递归没有结束之类的。

```cpp
void solve()
{
    int n;
    cin>>n;
    vi x(n+1),y(n+1),r(n+1);
    for(int i=1;i<=n;i++)
        cin>>x[i]>>y[i]>>r[i];
    vector<vi>adj(n+1,vi());
    auto calc=[&](int x){
        return 1ll*x*x;
    };
    for(int i=1;i<=n;i++)
        for(int j=i+1;j<=n;j++){
            if(calc(x[i]-x[j])+calc(y[i]-y[j])==calc(r[i]+r[j])){
                adj[i].push_back(j);
                adj[j].push_back(i);
            }
        }
    vi s(n+1,-1);
    for(int i=1;i<=n;i++){
        if(s[i]!=-1) continue;
        bool ok=true;
        int x=0,y=0;
        auto dfs=[&](auto &&self,int u)->void{
            if(s[u]) x++;
            else y++;
            // cerr<<u<<'\n';
            for(auto v:adj[u]){
                if(s[v]!=-1){
                    if(s[v]==s[u]) ok=false;
                    continue;
                }
                s[v]=s[u]^1;
                self(self,v);
            }
        };
        s[i]=0;
        dfs(dfs,i);
        if(ok&&x!=y){
            cout<<"YES\n";
            return;
        }
    }
    cout<<"NO\n";
}
```

### [CF1995C](https://codeforces.com/contest/1995/problem/C) *1800

给一个数组 $a$ ，每次可以选择一个 $a_i$ 将其变为 $a_i^2$ ，问最少需要多少次操作才能使其成为非递减数组。

直接乘肯定会爆。其实可以临时进行操作使得 $a_i$ 刚好大于 $a_{i-1}$ ，这样我们可以记录每个 $a_i$ 需要操作多少次。

如果 $a_i$ 先操作到刚好大于 $a_{i-1}$ ，那么只需要加上 $a_{i-1}$ 的操作次数就行。

记 $f_i$ 为 $a_i$ 需要操作的次数，如果 $a_i$ 比 $a_{i-1}$ 小，那么显然进行同样次数的操作是不够用的，所以我们需要先记录使得 $a_i$ 刚好大于 $a_{i-1}$ 的操作次数。若一开始就大于，就得把 $a_{i-1}$ 增大到刚好小于 $a_i$ 。

```cpp
void solve()
{
    int n;
    cin>>n;
    vl a(n+1);
    for(int i=1;i<=n;i++)
        cin>>a[i];
    ll ans=0;
    vl b(n+1);
    for(int i=2;i<=n;i++){
        if(a[i]==1&&a[i]<a[i-1]){
            cout<<"-1\n";
            return;
        }
    }
    for(int i=2;i<=n;i++){
        ll x=a[i],y=a[i-1];
        while(x<y){
            x*=x;
            b[i]++;
        }
        while(y!=1&&y*y<=x){
            y*=y;
            b[i]--;
        }
        b[i]+=b[i-1];
        cmax(b[i],0LL);
        ans+=b[i];
    }
    cout<<ans<<'\n';
}
```

