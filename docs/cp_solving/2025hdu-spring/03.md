## 2025“钉耙编程”中国大学生算法设计春季联赛（3）

## 1001

明天补

## 1005

由于城市间是互相可以到达的，所以只需要求联通块的数量。

可以用 DFS 或 并查集。

```cpp
constexpr int N = 3e5 + 10;
int f[N + 1];

int find(int x)
{
    // cerr << x << " " << f[x] << '\n';
    return f[x] == x ? x : f[x] = find(f[x]);
}

void ChatGptDeepSeek()
{
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++)
        f[i] = i;
    vector<int> a(n + 1);
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        // cerr << i << "\n";
        if (i - a[i] >= 1) {
            // cerr << i - a[i] << " " << find(i - a[i]) << '\n';

            f[find(i)] = find(i - a[i]);
            // f[i] = f[find(f[i - a[i]])];
        }
        if (i + a[i] <= n) {
            // cerr << i + a[i] << " " << find(i + a[i]) << '\n';
            f[find(i + a[i])] = find(f[i]);
            // f[i] = f[find(f[i + a[i]])];
        }

        // for (int j = 1; j <= n; j++)
        //     cerr << f[j] << " \n"[j == n];
    }
    int ans = 0;
    for (int i = 1; i <= n; i++) {
        if (find(f[i]) == i)
            ans++;
        // cerr << f[i] << '\n';
    }
    cout << ans - 1 << '\n';
}
```

## 1010

$\mid x_0-x_1\mid+\mid y_0-y_1\mid=max(x_0-x_1+y_0-y_1,$

$x_1-x_0+y_0-y_1,x_0-x_1+y_1-y_0,x_1-x_0+y_1-y_0)$  

所以到 $x_0,y_0$ 曼哈顿距离最大的点，一定是使得对应的 $x_1+y_1$ 或 $x_1-y_1$ 更大/更小。

```cpp
void ChatGptDeepSeek()
{
    int n, m;
    cin >> n >> m;
    vector<int> x(n), y(n);
    vector<int> a(4);
    a[1] = a[3] = 2e9;
    a[0] = a[2] = -2e9;
    for (int i = 0; i < n; i++)
    {
        cin >> x[i] >> y[i];
        a[0] = max(a[0], x[i] + y[i]);
        a[1] = min(a[1], x[i] + y[i]);
        a[2] = max(a[2], x[i] - y[i]);
        a[3] = min(a[3], x[i] - y[i]);
    }
    long long ans = 4e9;
    for (int i = 0; i < m; i++)
    {
        int X, Y;
        cin >> X >> Y;
        long long c = X + Y, d = X - Y;
        long long now = max({c - a[1], a[0] - c, a[2] - d, d - a[3]});
        ans = min(ans, now);
    }
    cout << ans << '\n';
}
```

