# 动态规划练习

> 2025-04-07

最近准备练点动态规划的题。。。但是其实好像只是在洛谷写了几个绿色的板子题。基本都是很简单的难度。

感觉也是可以稍微记录一下吧，但是后面得稍微写点难点的题了，虽然有的绿也是感觉没啥思路。

稍微总结一下。感觉都还是比较典的题，挺好的，补起来应该也不会很困难。

## [洛谷P2679](https://www.luogu.com.cn/problem/P2679)

感觉好像没啥好说的，枚举 $A_i$ 和 $B_j$ 匹配，匹配了多少段。$i$ 这一维只需要知道前一位的情况，可以用滚动数组。

$dp_{i,j,l}$ 表示 $A_{i}$ 和 $B_j$ 匹配用了 $l$ 段的方案数。

转移方程为 $dp_{i,j,l}=\sum\limits_{k=1}^{i-1}{dp_{k,j-1,l-1}}+dp_{i-1,j-1,l}$ 。

所以我们其实只需要知道前缀的和，以及 $dp_{i-1}$ ，所以可以使用滚动数组，再用一个数组来记前缀和。

```cpp
constexpr int mod = 1000000007;

int dp[2][202][202];
void ChatGptDeepSeek()
{
    int n, m, k;
    cin >> n >> m >> k;
    vector<char> A(n + 1), B(m + 1);
    for (int i = 1; i <= n; i++)
        cin >> A[i];
    for (int i = 1; i <= m; i++)
        cin >> B[i];
    vector<vector<int>> DP(m + 1, vector<int>(k + 1));
    dp[0][0][0] = DP[0][0] = 1;
    for (int i = 1; i <= n; i++)
    {

        vector nDP = DP;
        for (int j = 1; j <= min(i, m); j++)
        {
            if (A[i] == B[j])
            {
                for (int l = 1; l <= min(k, j); l++)
                {
                    dp[i & 1][j][l] = (dp[i & 1][j][l] + DP[j - 1][l - 1]) % mod;
                    nDP[j][l] = (nDP[j][l] + DP[j - 1][l - 1]) % mod;

                    dp[i & 1][j][l] = (dp[i & 1][j][l] + dp[(i ^ 1) & 1][j - 1][l]) % mod;
                    nDP[j][l] = (nDP[j][l] + dp[(i ^ 1) & 1][j - 1][l]) % mod;
                }
            }
        }
        for (int j = 0; j <= min(i, m); j++)
            for (int l = 1; l <= min(k, j); l++)
                dp[(i ^ 1) & 1][j][l] = 0;
        DP = nDP;
    }
    cout << DP[m][k] << '\n';
}
```

## [洛谷P1541](https://www.luogu.com.cn/problem/P1541)

这个很基础的题目了，虽然标的有绿，但是实际难度并非很高，应该还是比较容易想出来的。只需要枚举每种类型类型的卡片用了多少次。

因为走的步数是可以根据用的卡片的情况直接算出的。

```cpp
int dp[41][41][41][41];

void ChatGptDeepSeek()
{
    int n, m;
    cin >> n >> m;
    vector<int> a(n + 1);
    for (int i = 1; i <= n; i++)
        cin >> a[i];
    vector<int> b(4);
    for (int i = 1; i <= m; i++)
    {
        int x;
        cin >> x;
        b[x - 1]++;
    }
    dp[0][0][0][0] = a[1];
    for (int i = 0; i <= b[0]; i++)
        for (int j = 0; j <= b[1]; j++)
            for (int k = 0; k <= b[2]; k++)
                for (int l = 0; l <= b[3]; l++)
                {
                    int len = i * 1 + j * 2 + k * 3 + l * 4;
                    // dp[i][j][k][l] = a[1];
                    // cerr << len << '\n';
                    if (i - 1 >= 0)
                        dp[i][j][k][l] = max(dp[i][j][k][l], dp[i - 1][j][k][l] + a[len + 1]);
                    if (j - 1 >= 0)
                        dp[i][j][k][l] = max(dp[i][j][k][l], dp[i][j - 1][k][l] + a[len + 1]);
                    if (k - 1 >= 0)
                        dp[i][j][k][l] = max(dp[i][j][k][l], dp[i][j][k - 1][l] + a[len + 1]);
                    if (l - 1 >= 0)
                        dp[i][j][k][l] = max(dp[i][j][k][l], dp[i][j][k][l - 1] + a[len + 1]);
                }
    cout << dp[b[0]][b[1]][b[2]][b[3]] << '\n';
}
```

## [洛谷P1868](https://www.luogu.com.cn/problem/P1868)

也是比较容易想到的了。定义 $dp_i$ 为 $[1,i]$ 的最大答案。

那么对于每一个区间 $[l,r]$ ，我们可以更新 $dp_r=dp_{l-1}+r-l+1$ 。

```cpp
constexpr int N = 3e6 + 10;
int dp[N];

void ChatGptDeepSeek()
{
    int n;
    cin >> n;
    vector<pair<int, int>> v(n);
    for (int i = 0; i < n; i++)
        cin >> v[i].first >> v[i].second;
    sort(v.begin(), v.end());
    int j = 0;
    for (int i = 0; i <= 3000000; i++)
    {
        while (j < v.size() && v[j].first == i)
        {
            auto [l, r] = v[j];
            j++;
            dp[r] = max(dp[r], (l ? dp[l - 1] : 0) + r - l + 1);
        }
        dp[i] = max(dp[i], dp[i - 1]);
    }
    cout << dp[3000000] << '\n';
}
```

## [洛谷P1156](https://www.luogu.com.cn/problem/P1156)

也是比较常规的题目。维护每一个高度时的最大的体力值。

只需要注意下，输入的时间不全是按时间排序的。

```cpp
void ChatGptDeepSeek()
{
    int D, G;
    cin >> D >> G;
    vector<int> T(G), F(G), H(G);
    {
        vector<array<int, 3>> tmp(G);
        for (int i = 0; i < G; i++)
            cin >> tmp[i][0] >> tmp[i][1] >> tmp[i][2];
        sort(tmp.begin(), tmp.end());
        for (int i = 0; i < G; i++)
            T[i] = tmp[i][0], F[i] = tmp[i][1], H[i] = tmp[i][2];
    }
    // for (int i = 0; i < G; i++)
    //     cin >> T[i] >> F[i] >> H[i];
    dp[1][0] = 10;
    // for (int i = 1; i <= 25000; i++)
    //     dp[1][i] = dp[0][i] = -1;

    for (int i = 0; i < G; i++)
    {
        for (int j = 0; j <= 25000; j++)
        {

            if (dp[(i & 1) ^ 1][j] >= T[i])
            {
                if (j + H[i] >= D)
                {
                    // cerr << j << " " << dp[(i & 1) ^ 1][j] << " \n";
                    cout << T[i] << '\n';
                    return;
                }
                if (j + H[i] <= 25000)
                    dp[(i & 1)][j + H[i]] = max(dp[(i & 1)][j + H[i]], dp[(i & 1) ^ 1][j]);
                dp[(i & 1)][j] = max(dp[(i & 1)][j], dp[(i & 1) ^ 1][j] + F[i]);
                // cerr << i << " " << j << '\n';
            }
        }
        // for (int j = 1; j <= 25000; j++)
        //     dp[(i & 1) ^ 1][j] = -1;
    }
    // 如果不行的话 就一直吃！
    int now = 10;
    for (int i = 0; i < G; i++)
    {
        // cerr << now << " " << T[i] << '\n';
        if (now < T[i])
            break;
        now += F[i];
    }
    cout << now << '\n';
}
```

