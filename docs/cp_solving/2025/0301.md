# 3月1日-3月9日

> 以后只会记录每周的情况了，或者一段时间的。
>
> 因为很难保证每天能固定做多少个特定难度的题目，可能会有各种各样的事情，或者有比赛之类的。而且就是也正好可以记录一下这周都打了哪些比赛之类的。
>
> 以后新VP或者补最近比赛的题，就会放在比赛的界面或XCPC。然后日常找的写的题可能会放这。

# 3月3日

## [CF2065G](https://codeforces.com/contest/2065/problem/G) *1700

就上个星期才做过一道用了质数筛和筛最小质因子的题目，于是就想了下这题的性质很快就能对。

虽然也是WA了一次，看了数据才知道哪有问题。应该先排序的。可以少考虑很多。

```cpp
#include <bits/stdc++.h>
using namespace std;

constexpr int N = 2e5;
bitset<N + 1> is;
std::vector<int> primes;
// 记一下最小质因子
vector<int> minp(N + 1);

void solve()
{
    int n;
    cin >> n;
    long long ans = 0;
    int sum = 0;
    vector<int> cnt(n + 1);
    // auto sqrtI = [&](int x) {
    //     int y = (int)sqrt(x);
    //     return y * y == x ? y : 0;
    // };
    vector<int> a(n);
    for (auto& i : a)
        cin >> i;
    sort(a.begin(), a.end());
    for (int i = 1; i <= n; i++) {
        int x = a[i - 1];
        // cin >> x;
        cnt[x]++;
        if (!is[x]) {
            // 如果是一个质数，那么只能和其他的质数，除了它本身
            sum++;
            ans += sum - cnt[x];
            // 还得看一下 x*x
            if (1LL * x * x <= n)
                ans += cnt[x * x];
        } else {
            // 否则判一下最小质因子
            if (!is[x / minp[x]]) {
                // cerr << x << " " << minp[x] << '\n';
                // 如果只有两个质因子 那么答案加上这两个的数量
                // 当然它自己和自己也是可以的
                ans += cnt[minp[x]] + cnt[x];
                if (1LL * minp[x] * minp[x] != x)
                    ans += cnt[x / minp[x]];
            }
            // 2 3 ,6 ,2 7
        }
    }
    cout << ans << '\n';
}
/*
6
5 4 6 6 2 3
这为什么会是8呢？
5 2,5 3,2 3,2 4
6 2,6 3. 偶没有判 质数可能和倍数
*/
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    for (int i = 2; i <= N; i++) {
        if (!is[i]) {
            minp[i] = i;
            primes.push_back(i);
            // cerr << i << '\n';
            if (1LL * i * i > N)
                continue;
            for (int j = i * i; j <= N; j += i) {
                is[j] = true, minp[j] = i;
            }
        }
    }
    // cout << primes.size() << '\n';
    int T = 1;
    cin >> T;
    while (T--)
        solve();
    return 0;
}
```

## [CF2065F](https://codeforces.com/contest/2065/F) *1700

这个更是简单了。满足答案的情况实际上只需要判断长度为2和3的路径是否满足。就很简单了。但是DFS是不是可能会超时来着。

只要连边的时候就处理就行了。好吧DFS好像也行。

看了下，其实也可以输入时先判下长度为2的，然后找的时候只需要遍历每个点连的点，看这一次标记是否有重复的。也很好。差不多，或者每次开个set。

```cpp
void solve()
{
    int n;
    cin >> n;
    vector<int> a(n + 1);
    string s(n, '0');
    for (int i = 1; i <= n; i++)
        cin >> a[i];
    vector<set<int>> g(n + 1);
    // vector<vector<int>> adj(n + 1, vector<int>());
    for (int i = 1; i < n; i++) {
        int u, v;
        cin >> u >> v;
        if (a[u] == a[v]) {
            s[a[u] - 1] = '1';
        }
        if (g[u].contains(a[v])) {
            s[a[v] - 1] = '1';
        } else
            g[u].insert(a[v]);
        if (g[v].contains(a[u])) {
            s[a[u] - 1] = '1';
        } else
            g[v].insert(a[u]);
        // g[u].insert(a[v]), g[v].insert(a[u]);
    }
    // auto dfs = [&](auto&& self, int u, int pre, int val, int cnt, int len) -> void {
    //     if ((s[val - 1] == '1') || (pre && cnt > 0)) {
    //         // cerr << pre << " " << u << " " << val << '\n';
    //         s[val - 1] = '1';
    //         return;
    //     }
    //     if (len == 3)
    //         return;
    //     for (auto v : adj[u]) {
    //         if (v == pre)
    //             continue;
    //         if (a[v] == val)
    //             self(self, v, u, val, cnt + 1, len + 1);
    //         else
    //             self(self, v, u, val, cnt - 1, len + 1);
    //     }
    // };
    // for (int i = 1; i <= n; i++) {
    //     dfs(dfs, i, 0, a[i], 1, 0);
    // }
    cout << s << '\n';
}
```

`set::count` 和 `contains` 效率差别不是很大，都是 $\log n$ ，但是 `multiset::count` 的复杂度时 `n` 。



# details

## 3月1日

- [x] CF2071C
- [x] 24四川省赛BFG
- [x] ABC394ABCD

补了昨晚没写出来的 [CF2071C](https://codeforces.com/contest/2071/problem/C) 。

中午VP了2024年四川省赛，大概110名铜，54银，我们80。

只能说算正常吧，得多补题啊，能自己写出来的，大概率帮助不大，只有觉得坐牢的题目才会有些价值。。。

这场 B， F ， G ，补题都可以看下。

晚上打了 ABC394 ，只写了4题，E题没写出来，没多少时间了，D题写得太慢了，E一开始又想错了。

应该是dijkstra板子题。

## 3月2日

- [x] ABC395E
- [x] ABC395F
- [x] CF2071D1
- [x] 24四川省赛B
- [x] 24四川省赛F
- [x] 牛客周赛83 ABCDE

## 3月3日

- [x] CF2065G
- [x] CF2065F



## 3月2日

