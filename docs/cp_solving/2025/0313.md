# 部分做题记录

> 这里将记录每天写的一些不属于最新的比赛里的题目，并且是对当前的我稍微有点难度的题目。

## [CF2063D](https://codeforces.com/contest/2063/problem/D) *2000

> 2025-03-12

这题并不难的，没看题解45分钟写出来的，WA了一发数组没开 `ll` ，耽误了三四分钟。

首先我们先考虑 $x$ 取 $1$ 的答案，必然是从上面或者下面选两个距离最远的点，再从另一边随便选一个点。

考虑 $x$ 取 $2$ 的情况呢，会不会把 $x=1$ 的三个点给还原回来呢? 什么时候会还原回来？

如果你能直接再选 $3$ 个合法的点出来，那么就不需要再去改之前的方案了。

因为你选另一边的点当底边显然不会影响这一边的底边的面积。至于说把这两个点重新分配到这边组两个底边，就更不可能了。

所以只有当前的点不够再开一个新的三角形了，才有可能拆一个已经拼好的三角形。并且拆了之后得能拼出两个三角形才行。

考虑一下，拆一个三角形会使一边增加2个点，另一边加1个点。新拼成的两个三角形的顶点是一定在同一条边上的。。。我上午写的时候都没考虑这个来着，就只想着是会在同一边，虽然这确实挺直觉的，也很好推的。可能是因为样例的提示吧。

然后就是直接模拟就好了。 拆一个三角形的话，肯定得删边最短的那个。

```cpp
void ChatGptDeepSeek()
{
    // 主要是看上面取多少个 下面取多少个
    int n, m;
    cin >> n >> m;
    vector<int> a(n + 1), b(m + 1);
    set<int> u, d;
    priority_queue<int, vector<int>, greater<>> uq, dq;
    for (int i = 1; i <= n; i++)
        cin >> a[i], u.insert(a[i]);
    for (int i = 1; i <= m; i++)
        cin >> b[i], d.insert(b[i]);
    int U = 0, D = 0;
    ll ans = 0;
    vector<ll> res;
    for (int i = 1;; i++)
    {
        int uu = 0, dd = 0;
        if (u.size() >= U + 2 && d.size() >= D + 1)
        {
            uu = *u.rbegin() - *u.begin();
        }
        if (d.size() >= D + 2 && u.size() >= U + 1)
        {
            dd = *d.rbegin() - *d.begin();
        }
        // cerr<<dd<<" "<<uu<<'\n';
        if (dd + uu == 0)
        {
            // cerr<<u.size()<<" "<<U<<" "<<d.size()<<" "<<D<<'\n';
            // cerr<<"empty: "<<uq.size()<<'\n';
            // 上面的减去两个，或者是下面的减去两个
            if (u.size() >= U + 3 && !dq.empty())
            {
                ans += *u.rbegin() - *u.begin();
                // uq.push(*u.rbegin() - *u.begin());
                u.erase(u.begin()), u.erase(prev(u.end()));
                ans += *u.rbegin() - *u.begin();
                // uq.push(*u.rbegin() - *u.begin());
                u.erase(u.begin()), u.erase(prev(u.end()));
                ans -= dq.top();
                dq.pop();
                U--;
            }
            else if (d.size() >= D + 3 && !uq.empty())
            {
                // cerr<<"here\n";
                ans += *d.rbegin() - *d.begin();
                // dq.push(*d.rbegin() - *d.begin());
                d.erase(d.begin()), d.erase(prev(d.end()));
                ans += *d.rbegin() - *d.begin();
                // dq.push(*d.rbegin() - *d.begin());
                d.erase(d.begin()), d.erase(prev(d.end()));
                ans -= uq.top();
                uq.pop();
                D--;
            }
            else
                break;
        }
        else if (dd >= uu)
        {
            d.erase(d.begin());
            d.erase(prev(d.end()));
            U++;
            ans += dd;
            dq.push(dd);
        }
        else
        {
            u.erase(u.begin());
            u.erase(prev(u.end()));
            D++;
            ans += uu;
            uq.push(uu);
        }
        // cout<<ans<<" ";
        res.push_back(ans);
    }
    cout << res.size() << '\n';
    for (auto x : res)
        cout << x << " ";
    cout << '\n';
}
```

## [CF2069E](https://codeforces.com/contest/2069/problem/E) *2300

> 2025-03-14

由于是没有 AA 和 BB 这种的，所以连着的 A B ， 我们只能花单个的 A 和 B 。所以我们可以把序列拆成若干个首尾不同的序列。

例如 ABABA ABABAB BABAB BABA 这种。看起来会不太好处理。。但是当你看了题解之后就很简单了。。观察一下，对于奇数长度的，我们使用 AB 和 BA ， 额外的单个的花费是相同的。但是偶数长度的 ABABAB 如果要用 BA 的话会比使用 AB 多一个额外的花费。BABABA 同理。

所以我们优先把偶数长度的处理完，然后剩下的多的数量就去处理其他的。并且我们每用对应的 AB 或 BA 处理完一个偶数长度的序列都可以省一些花费，所以我们先处理长度较短的字符串。

然后就好好分类讨论就好了。（其实都没必要存字符串

```cpp
void ChatGptDeepSeek()
{
    string s;
    cin >> s;
    int a, b, ab, ba;
    cin >> a >> b >> ab >> ba;
    vector<string> v;
    for (int i = 0; i < s.size(); i++) {
        int j = i + 1;
        string t(1, s[i]);
        while (j < s.size() && s[j] != s[j - 1]) {
            t += s[j];
            j++;
        }
        i = j - 1;
        if (t.size() > 1)
            v.push_back(t);
    }
    sort(v.begin(), v.end(), [](string x, string y) {
        if ((x.size() ^ y.size() ^ 1) & 1)
            return x.size() < y.size();
        // if(x.size()==y.size())
        //     return x<y;
        return x.size() % 2 < y.size() % 2;
    });
    int A = count(s.begin(), s.end(), 'A'), B = s.size() - A;
    for (auto x : v) {
        // cerr<<x<<" \n";
        int len = x.size();
        if (x.size() & 1) {
            // 奇数用谁都一样的
            while (ab && len > 1) {
                A--, B--;
                ab--;
                len -= 2;
            }
            while (ba && len > 1) {
                A--, B--;
                ba--;
                len -= 2;
            }
        } else {
            if (x.front() == 'A') {
                if (ab >= len / 2) {
                    ab -= len / 2;
                    A -= len / 2, B -= len / 2;
                    len = 0;
                    // cerr<<ab<<'\n';
                } else {
                    len -= 2 * ab;
                    A -= ab, B -= ab;
                    ab = 0;
                }
                if (len) {
                    if (ba >= (len - 2) / 2) {
                        ba -= (len - 2) / 2;
                        A -= (len - 2) / 2, B -= (len - 2) / 2;
                    } else {
                        A -= ba, B -= ba, ba = 0;
                    }
                }
            } else {
                if (ba >= len / 2) {
                    ba -= len / 2;
                    A -= len / 2, B -= len / 2;
                    len = 0;
                } else {
                    len -= 2 * ba;
                    A -= ba, B -= ba;
                    ba = 0;
                }
                if (len) {
                    if (ab >= (len - 2) / 2) {
                        ab -= (len - 2) / 2;
                        A -= (len - 2) / 2, B -= (len - 2) / 2;
                    } else {
                        A -= ab, B -= ab, ab = 0;
                    }
                }
            }
        }
    }
    // cerr<<ab<<" "<<ba<<'\n';
    assert(A >= 0 && B >= 0);
    if (A <= a && B <= b)
        cout << "YES\n";
    else
        cout << "NO\n";
}
```

## [CF1981C](https://codeforces.com/contest/1981/problem/C) *1800

> 2025-03-14

好题。。

可以看成一颗满二叉树， $x$ 可以走到 $2x$ 和 $2x+1$ ，这正好对应的是二叉树上的两个子节点。但是知道了这个也确实没办法做吧。

于是题解告诉我们这题与 LCA 有关。然后我去看了下 LCA ，回来发现，这这不对啊 $10^8$ 这让我怎么 LCA 啊。。。

这题可以转换成给两个二叉树的点，我们要使它们相遇。那么最短的距离就是在它们两到LCA的路径上 ，然后如果有多的步数，就每次走到相邻的再走回来就行。当然剩余的步数必须是偶数才行。

考虑一下 再它们走到 相遇 之前，路径已经是最短的了，所以只能额外消耗步数。这一个过程是没有办法消耗奇数步的。因为比如一个节点后退了一步，那么这一步后面也是会补回来的 或者说是消耗了你的一个前进的步数，所以总体一直是奇偶保持不变的。

而它们相遇之后，同样不可能去消耗奇数步，要么一个节点出去再回来，这样是 2 倍的路程，消耗必然是偶数，如果它们一起走，那消耗的步数也必然是偶数。

所以现在问题转换成了如何让它们走到 LCA 上，看了哥哥的代码，太牛了。。。就是左右端点，哪个大就把哪个除以二。。这就是相当于把一个点往上移了一层，我们最终是要把两个点都移动到 LCA 那一层。而由于是一颗满二叉树，所以最多只会有二三十层的。如果一个节点数值更大，那么它的层数一定是大于等于另一个点的。

```cpp
void ChatGptDeepSeek()
{
    int n;
    cin >> n;
    vector<int> a(n + 1);
    for (int i = 1; i <= n; i++)
        cin >> a[i];
    a[0] = 1;
    int l = -1, r = 0;
    for (int i = 1; i <= n; i++) {
        if (a[i] != -1) {
            r = i;
            if (l == -1) {
                for (int j = i - 1; j >= 1; j--)
                    a[j] = a[j + 1] == 1 ? 2 : a[j + 1] / 2;
            } else {
                int L = l, R = r;
                while (L < R - 1) {
                    if (a[L] >= a[R]) {
                        a[L + 1] = a[L] == 1 ? 2 : a[L] / 2;
                        L++;
                    } else {
                        a[R - 1] = a[R - 1] == 1 ? 2 : a[R] / 2;
                        R--;
                    }
                }
                if (a[L] != a[R] / 2 && a[L] / 2 != a[R]) {
                    cout << "-1\n";
                    return;
                }
            }
            l=i;
        }
    }
    for (int i = r + 1; i <= n; i++)
        a[i] = a[i - 1] == 1 ? 2 : a[i - 1] / 2;
    for (int i = 1; i <= n; i++)
        cout << a[i] << " \n"[i == n];
}
```

就像这题以及很多的 CF 题，你要问用了什么算法，好像真没什么算法。但你要说难不难。。。我感觉还是挺难的。

多做点好题吧，积攒一下（）。

## [CF1975D](https://codeforces.com/contest/1975/problem/D) *1700

> 2025-03-17

很好的题目，即使是我也能感到心潮澎湃。

我们希望蓝色的点早点走到被染成红色的点上。

因为从一个点遍历树，最少的情况每个边都会被走 $2$ 遍，但是这个情况下我们最后一次是不用回去的。

所以贡献会减去最后去的一个点到根节点的距离，所以我们希望最后一个点距离根节点尽量的远。并且蓝色的点肯定一走到红色的区域就该开始了，因为红色可以自动去把蓝色该走的地方给走了。而且即使这时调整位置，距离根节点最大的距离也最多只会减一，并不会使得答案更小。

```cpp
// 感觉只能一个子树一个子树的走。。。
// 如果蓝色的不在根节点或与根相连
// 那么我们肯定让红色的先走它在的子树
// 然后它自己走到深度为1的点就好了 否则它需要走到根节点去
// 如果在根节点 那么需要额外花费两个费用
// 遍历一个子树必然会把这个子树的每条边都走两次 除了最后去的一些边。。
// 。。。。好像很不好讨论的。。。。

// 好像还真是什么很神奇的结论。。。
// 太牛，也是直接看了题解。。
// 遍历一颗树 如果最后要回到根节点 那么最小的走的路程就是每条边都走两次
// 但是如果最后不回来呢？实际上就是减少了最后一个点到根节点的距离
// 所以如果最后不回来，那我们希望它最后一个去的点距离根节点最远

// 所以我们希望a b 尽可能快的相遇。。
// 无法相遇也没关系。因为那就相当于红色比蓝色多一步了，那它显然可以去提前把蓝色要走的路给染色好
// 如果可以相遇 那就正好一起走就直接染成蓝色
// 所以其实就是希望蓝色的点尽可能快地走到被染成红色的点

// 所以最后的答案就是，2(n-1)-d
// d 为 a b 相遇的点到最远的点的距离
// 有没有可能移动初始的点使得d 更大呢？没有
// 因为你一次移动最多就使得d+1 这跟不移动 没啥区别

// Date: 2025-03-17
// Time: 16:25:11

#include <bits/stdc++.h>
using namespace std;

void ChatGptDeepSeek()
{
    int n;
    cin >> n;
    int a, b;
    cin >> a >> b;
    vector<vector<int>> adj(n + 1, vector<int>());
    for (int i = 1; i < n; i++) {
        int u, v;
        cin >> u >> v;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    vector<int> dep(n + 1), f(n + 1);
    auto dfs = [&](auto&& self, int u, int pre) -> void {
        for (auto v : adj[u]) {
            if (v == pre)
                continue;
            f[v] = u;
            dep[v] = dep[u] + 1;
            self(self, v, u);
        }
    };
    dfs(dfs, a, 0);
    int st = b, ans = 2 * (n - 1);
    for (int i = 1; i <= dep[b] / 2; i++, ans++)
        st = f[st];
    if(dep[b]&1) st=f[st],ans++;
    dep[st] = 0;
    dfs(dfs, st, 0);
    cout << ans - *max_element(dep.begin() + 1, dep.end()) << '\n';
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int T = 1;
    cin >> T;
    while (T--)
        ChatGptDeepSeek();
    return 0;
}
```

## [CF1974E](https://codeforces.com/contest/1974/problem/E) *1800

> 2025-03-17

其实就是一个非常基础的dp啊。。。

但是我 WA + TLE 好多发。

```cpp
		vector ndp = dp;
        for (int j = 0; j + h[i] < dp.size(); j++) {
            if (have >= dp[j] + c[i]) {
                ndp[j + h[i]] = min(ndp[j + h[i]], dp[j] + c[i]);
                assert(j + h[i] <= m * 1000);
            }
        }
        dp = ndp;
        have += x;
```

刚开始是这样写的，之前一般都这样写的。。。但是我发现这其实没必要多开一个数组。。。因为只会影响后面的，所以直接倒着遍历就可以。。

```cpp
        for (int j = n; j - h[i] >= 0; j--) {
            if (dp[j - h[i]] + c[i] <= have)
                dp[j] = min(dp[j], dp[j - h[i]] + c[i]);
        }
        have += x;
```

但是 $2202ms$ ， 原因是我开的 vector 以及每次都开的最大的，虽然过了啊，但是其实题目限制了 $\sum h_i$ ，我理解有问题啊，那其实就该直接每次开 $\sum h$ 的空间就行了。

```cpp
using ll = long long;

constexpr ll inf = 1e18;
ll dp[1000 * 100 + 1];

void ChatGptDeepSeek()
{
    int m, x;
    cin >> m >> x;
    vector<int> c(m + 1), h(m + 1);
    int n = 0;
    for (int i = 1; i <= m; i++) {
        cin >> c[i] >> h[i];
        for (int j = 1; j <= h[i]; j++)
            dp[n + j] = inf;
        n += h[i];
    }
    // vector<ll> dp(1000 * m + 1, inf);

    dp[0] = 0;
    ll have = 0;
    for (int i = 1; i <= m; i++) {
        // vector ndp = dp;
        for (int j = n; j - h[i] >= 0; j--) {
            if (dp[j - h[i]] + c[i] <= have)
                dp[j] = min(dp[j], dp[j - h[i]] + c[i]);
        }
        have += x;
    }
    for (int i = n; i >= 0; i--) {
        if (dp[i] != inf) {
            cout << i << "\n";
            return;
        }
    }
}
```

